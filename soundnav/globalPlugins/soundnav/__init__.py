# -*- coding: utf-8 -*-
# __init__.py - Main global plugin for SoundNav
# Part of SoundNav add-on for NVDA

import os
import globalPluginHandler
import addonHandler
import speech
import ui
import api
import textInfos
from scriptHandler import script

from .soundPlayer import SoundPlayer
from .roleMapper import get_sounds_for_object
from .settingsPanel import init_configuration, get_config, set_config, SoundNavSettingsPanel

addonHandler.initTranslation()

class GlobalPlugin(globalPluginHandler.GlobalPlugin):
    """
    Main global plugin for SoundNav add-on.

    Provides spatial 3D audio feedback for different control types,
    optionally suppressing spoken role labels to reduce redundancy.
    """

    # Translators: Script category for Sound Navigation commands
    scriptCategory = _("Sound Navigation")

    def __init__(self, *args, **kwargs):
        """Initialize the SoundNav add-on."""
        super().__init__(*args, **kwargs)

        # Initialize configuration
        init_configuration()

        # Initialize sound player with sounds directory
        sounds_dir = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            "sounds"
        )
        self.sound_player = SoundPlayer(sounds_dir)

        # Hook into speech system to suppress role labels
        # IMPORTANT: Must hook speech.speech.getPropertiesSpeech (the actual function NVDA uses internally)
        # Hooking only speech.getPropertiesSpeech (the re-export) doesn't intercept actual speech generation
        self._original_getSpeechTextForProperties = speech.speech.getPropertiesSpeech
        speech.speech.getPropertiesSpeech = self._hook_getSpeechTextForProperties
        # Also update the re-export at speech module level for compatibility
        speech.getPropertiesSpeech = speech.speech.getPropertiesSpeech

        # Hook into speech system for browse mode sound support
        # Use monkey-patch of speech.speech.speak to intercept ALL speech,
        # including browse mode speech generated by speakTextInfo()
        self._last_browse_element = None
        self._original_speech_speak = speech.speech.speak
        speech.speech.speak = self._hook_speech_speak
        speech.speak = speech.speech.speak

        # Register settings panel
        self.createMenu()

    def createMenu(self):
        """Register the settings panel in NVDA's settings dialog."""
        from gui.settingsDialogs import NVDASettingsDialog
        NVDASettingsDialog.categoryClasses.append(SoundNavSettingsPanel)

    def terminate(self):
        """Clean up when add-on is disabled."""
        # Restore speech.speak hook
        speech.speech.speak = self._original_speech_speak
        speech.speak = speech.speech.speak
        # Restore the original getPropertiesSpeech function
        speech.speech.getPropertiesSpeech = self._original_getSpeechTextForProperties
        speech.getPropertiesSpeech = speech.speech.getPropertiesSpeech

        # Remove settings panel
        from gui.settingsDialogs import NVDASettingsDialog
        try:
            NVDASettingsDialog.categoryClasses.remove(SoundNavSettingsPanel)
        except ValueError:
            # Already removed or not present
            pass

    def is_enabled(self):
        """
        Check if the add-on is currently enabled.

        Returns:
            True if enabled, False otherwise
        """
        return get_config("enabled")

    def _hook_getSpeechTextForProperties(self, *args, **kwargs):
        """
        Hook function to intercept speech generation.

        Removes role and state labels from speech output when corresponding options are enabled.
        This prevents NVDA from saying "button", "link", "checked", "visited", etc.

        Uses *args/**kwargs to match the original function's signature exactly,
        avoiding TypeError when NVDA omits the 'reason' parameter (uses its default).
        Wrapped in try/except to never break NVDA's speech pipeline or navigation.
        """
        try:
            if self.is_enabled():
                # Suppress role labels if enabled
                if get_config("suppressRoleLabels"):
                    if 'role' in kwargs:
                        del kwargs['role']

                # Suppress state labels if enabled
                if get_config("suppressStateLabels"):
                    if 'states' in kwargs:
                        del kwargs['states']
        except Exception:
            pass

        # Call the original function with unmodified signature
        return self._original_getSpeechTextForProperties(*args, **kwargs)

    def _hook_speech_speak(self, speechSequence, *args, **kwargs):
        """
        Hook for speech.speech.speak() to trigger browse mode sounds.

        Always calls the original speak function. Browse mode sound processing
        is wrapped in try/except to never break NVDA speech.
        """
        try:
            self._process_browse_mode_sound(speechSequence)
        except Exception:
            import log
            log.debugWarning("SoundNav: error in browse mode sound", exc_info=True)
        self._original_speech_speak(speechSequence, *args, **kwargs)

    def _extract_role_from_speech(self, speechSequence):
        """
        Extract the innermost control role and states from a speech sequence.

        In browse mode, speech sequences contain FieldCommand objects representing
        the control hierarchy (outermost to innermost). We find the innermost
        (most specific) control before the first text content, which is the
        element NVDA is about to announce.

        This is more reliable than reading POSITION_CARET, which may still
        point to the previous element when speak() is called.

        Returns:
            tuple: (role, states) or (None, set()) if no role found
        """
        role = None
        states = set()
        found_control = False
        try:
            for item in speechSequence:
                # Check for FieldCommand (controlStart) using duck typing
                # for compatibility across NVDA versions
                if hasattr(item, 'command') and hasattr(item, 'field'):
                    if item.command == "controlStart" and item.field:
                        field_role = item.field.get("role")
                        if field_role is not None:
                            role = field_role
                            states = item.field.get("states", set()) or set()
                            found_control = True
                elif found_control and isinstance(item, str) and item.strip():
                    # Stop at first text after a control start - we have
                    # the innermost control for this element
                    break
        except Exception:
            pass
        return role, states

    def _process_browse_mode_sound(self, speechSequence=None):
        """
        Process browse mode navigation and play 3D positional sounds.

        Uses the speechSequence to determine the element role (avoids off-by-one
        when the virtual caret hasn't been updated yet). Falls back to reading
        the caret position if the speech sequence doesn't contain role info.
        """
        if not self.is_enabled():
            return
        if not get_config("browseModeSound"):
            return

        focus = api.getFocusObject()
        ti = getattr(focus, 'treeInterceptor', None)
        if ti is None:
            return
        if getattr(ti, 'passThrough', False):
            return

        # Extract role from speech sequence - this has the CORRECT element info
        # even when the virtual caret hasn't moved yet
        speech_role = None
        speech_states = set()
        if speechSequence:
            speech_role, speech_states = self._extract_role_from_speech(speechSequence)

        # Get object at caret for location (3D positioning) and as fallback
        try:
            info = ti.makeTextInfo(textInfos.POSITION_CARET)
            obj = info.NVDAObjectAtStart
        except Exception:
            obj = None
        if obj is None:
            return

        # Determine sounds: prefer speech-derived role over stale caret object
        if speech_role is not None:
            import types
            elem = types.SimpleNamespace(
                role=speech_role,
                states=speech_states,
                location=getattr(obj, 'location', None)
            )
            sound_filenames = get_sounds_for_object(elem)
            actual_role = speech_role
        else:
            sound_filenames = get_sounds_for_object(obj)
            actual_role = getattr(obj, 'role', None)

        if not sound_filenames:
            self._last_browse_element = None
            return

        # Deduplication using the correct role
        location = getattr(obj, 'location', None)
        location_tuple = tuple(location) if location is not None else ()
        element_key = (actual_role, location_tuple)

        if element_key == self._last_browse_element:
            return

        self._last_browse_element = element_key
        self.sound_player.play_for_object(obj, sound_filenames)

    def play_for_object(self, obj):
        """
        Play appropriate sounds for an NVDA object.

        Args:
            obj: NVDA object to play sounds for
        """
        if not self.is_enabled():
            return

        # Get list of sound filenames for this object
        sound_filenames = get_sounds_for_object(obj)

        # Play the sounds with 3D positioning
        if sound_filenames:
            self.sound_player.play_for_object(obj, sound_filenames)

    # ===== Event Handlers =====

    def event_gainFocus(self, obj, nextHandler):
        """
        Handle focus changes (keyboard navigation with Tab, arrows, etc.).

        Args:
            obj: The object that gained focus
            nextHandler: Function to call to propagate the event
        """
        # Reset browse mode deduplication when focus changes (e.g., Tab key)
        self._last_browse_element = None

        if self.is_enabled():
            try:
                self.play_for_object(obj)
            except Exception:
                # Silently ignore errors to prevent breaking NVDA
                pass

        # CRITICAL: Always call nextHandler to propagate the event
        nextHandler()

    def event_becomeNavigatorObject(self, obj, nextHandler, isFocus=False):
        """
        Handle NVDA object navigation (NVDA+numpad arrows).

        Args:
            obj: The object that became the navigator object
            nextHandler: Function to call to propagate the event
            isFocus: True if this object also has focus
        """
        # Only play sound if enabled and this is not also the focused object
        # (to avoid playing sound twice for the same object)
        if self.is_enabled() and not isFocus:
            try:
                self.play_for_object(obj)
            except Exception:
                # Silently ignore errors to prevent breaking NVDA
                pass

        # CRITICAL: Always call nextHandler to propagate the event
        nextHandler()

    # ===== Scripts (Keyboard Commands) =====

    @script(
        # Translators: Description for toggle Sound Navigation script
        description=_("Toggle Sound Navigation on/off"),
        gesture="kb:NVDA+shift+s"
    )
    def script_toggleSoundNav(self, gesture):
        """
        Toggle the add-on on/off.

        Keyboard shortcut: NVDA+Shift+S
        """
        enabled = get_config("enabled")
        set_config("enabled", not enabled)

        if not enabled:
            # Was disabled, now enabled
            # Translators: Message when Sound Navigation is enabled
            ui.message(_("Sound Navigation enabled"))
        else:
            # Was enabled, now disabled
            # Translators: Message when Sound Navigation is disabled
            ui.message(_("Sound Navigation disabled"))
